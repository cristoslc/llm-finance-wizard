#!/usr/bin/env bash
# fetch-remote-skill.sh — Fetch a skill from a remote Git repo and stamp .source.yml
#
# Usage:
#   fetch-remote-skill.sh <repo-url> <skill-path> [ref] [target-dir]
#
# Arguments:
#   repo-url    — Git remote URL (HTTPS or SSH)
#   skill-path  — Path to the skill directory within the source repo
#   ref         — Branch, tag, or commit (default: HEAD)
#   target-dir  — Local directory to install into (default: .agents/skills)
#
# Requires: git, tar, sha256sum or shasum, date
# Generates: .source.yml provenance manifest per ADR-002

set -euo pipefail

# --- Arguments ---
REPO_URL="${1:?Usage: fetch-remote-skill.sh <repo-url> <skill-path> [ref] [target-dir]}"
SKILL_PATH="${2:?Usage: fetch-remote-skill.sh <repo-url> <skill-path> [ref] [target-dir]}"
REF="${3:-HEAD}"
TARGET_DIR="${4:-.agents/skills}"

SKILL_NAME="$(basename "$SKILL_PATH")"
SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"

# --- Portable sha256 ---
sha256_hash() {
  if command -v sha256sum >/dev/null 2>&1; then
    sha256sum | cut -d' ' -f1
  elif command -v shasum >/dev/null 2>&1; then
    shasum -a 256 | cut -d' ' -f1
  else
    echo "ERROR: Neither sha256sum nor shasum found" >&2
    exit 1
  fi
}

# --- Portable ISO 8601 UTC timestamp ---
iso_timestamp() {
  if date -u +"%Y-%m-%dT%H:%M:%SZ" 2>/dev/null; then
    return
  fi
  # Fallback for systems where -u is not supported (unlikely on POSIX)
  date +"%Y-%m-%dT%H:%M:%SZ"
}

# --- Temp directory with cleanup ---
TMPDIR_WORK="$(mktemp -d)"
cleanup() { rm -rf "$TMPDIR_WORK"; }
trap cleanup EXIT

echo "Fetching skill '$SKILL_NAME' from $REPO_URL (ref: $REF)..."

# --- Clone (shallow, single-branch) ---
git clone --depth 1 --branch "$REF" --single-branch --quiet \
  "$REPO_URL" "$TMPDIR_WORK/repo" 2>/dev/null || \
git clone --depth 1 --quiet "$REPO_URL" "$TMPDIR_WORK/repo"

# If REF was not a branch/tag (e.g., a commit SHA), check it out
if [ "$REF" != "HEAD" ]; then
  git -C "$TMPDIR_WORK/repo" checkout --quiet "$REF" 2>/dev/null || true
fi

# --- Resolve commit SHA ---
COMMIT_SHA="$(git -C "$TMPDIR_WORK/repo" rev-parse HEAD)"

# --- Validate skill path exists in source ---
if [ ! -d "$TMPDIR_WORK/repo/$SKILL_PATH" ]; then
  echo "ERROR: Skill path '$SKILL_PATH' not found in repository" >&2
  exit 1
fi

if [ ! -f "$TMPDIR_WORK/repo/$SKILL_PATH/SKILL.md" ]; then
  echo "ERROR: No SKILL.md found at '$SKILL_PATH' — not a valid skill directory" >&2
  exit 1
fi

# --- Copy skill to target ---
DEST="$TARGET_DIR/$SKILL_NAME"
mkdir -p "$DEST"

# Remove old files (except .source.yml which we'll overwrite anyway)
if [ -d "$DEST" ]; then
  find "$DEST" -mindepth 1 -not -name '.source.yml' -delete 2>/dev/null || true
fi

cp -R "$TMPDIR_WORK/repo/$SKILL_PATH/." "$DEST/"

# Remove any .source.yml that came from upstream (we generate our own)
rm -f "$DEST/.source.yml"

# --- Compute integrity hash ---
# Deterministic tar: sorted entries, no timestamps, exclude .source.yml
INTEGRITY_DIGEST="$(tar cf - --exclude='.source.yml' -C "$TARGET_DIR" "$SKILL_NAME" 2>/dev/null | sha256_hash)"

# --- Generate .source.yml ---
FETCHED_AT="$(iso_timestamp)"
FETCHED_BY="fetch-remote-skill.sh"

cat > "$DEST/.source.yml" <<YAML
# .source.yml — Remote skill provenance manifest
# Machine-generated by ${FETCHED_BY}. Do not edit manually.
# Schema: ADR-002-Remote-Skills-Reference-Pattern

source:
  repository: ${REPO_URL}
  ref: ${REF}
  commit: ${COMMIT_SHA}
  path: ${SKILL_PATH}

skill:
  name: ${SKILL_NAME}

fetched:
  at: "${FETCHED_AT}"
  by: ${FETCHED_BY}

integrity:
  algorithm: sha256
  digest: ${INTEGRITY_DIGEST}
YAML

echo "OK: Skill '$SKILL_NAME' installed to $DEST"
echo "    Commit: $COMMIT_SHA"
echo "    Integrity: $INTEGRITY_DIGEST"
